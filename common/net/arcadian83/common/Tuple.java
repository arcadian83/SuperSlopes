package net.arcadian83.common;

import java.util.ArrayList;

public class Tuple implements Comparable<Tuple> {
	public Integer x;
	public Integer y;
	public Integer z;
	
	public Tuple(int x, int y, int z) {
		this.x = x;
		this.y = y;
		this.z = z;
	}
	
	public Tuple(Tuple toCopy) {
		this.x = toCopy.x;
		this.y = toCopy.y;
		this.z = toCopy.z;
	}
	
	// auto-generated by Eclipse
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((x == null) ? 0 : x.hashCode());
		result = prime * result + ((y == null) ? 0 : y.hashCode());
		result = prime * result + ((z == null) ? 0 : z.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object other) {
		if (other == null) return false;
	    if (other == this) return true;
	    if (!(other instanceof Tuple))return false;
	    Tuple otherTuple = (Tuple)other;
	    
		if(this.x != otherTuple.x) return false;
		if(this.y != otherTuple.y) return false;
		if(this.z != otherTuple.z) return false;
		return true;
	}
	
	@Override
	public int compareTo(Tuple other)
    {
		if(other == this) return 0;
    
	    int xCompare = this.x.compareTo(other.x);
	    if(xCompare != 0) return xCompare;
	    
	    int yCompare = this.y.compareTo(other.y);
	    if(yCompare != 0) return yCompare;
	    
	    return z.compareTo(other.z);
    }
	
	// given a direction, determine if this Tuple is outward in that direction
	public boolean facesDirection(int direction) {
		switch(direction) {
			case 0: return (y == -1);
			case 1: return (y ==  1);
			case 2: return (z == -1);
			case 3: return (z ==  1);
			case 4: return (x ==  1);
			case 5: return (x == -1);
		}
		
		return false;
	}
	
	// given a corner Tuple, determine if we are adjacent (including diagonals) to it
	public boolean surroundsCorner(Tuple corner) {
		if(corner.x == -1 && x ==  1) return false;
		if(corner.x ==  1 && x == -1) return false;
		if(corner.y == -1 && y ==  1) return false;
		if(corner.y ==  1 && y == -1) return false;
		if(corner.z == -1 && z ==  1) return false;
		if(corner.z ==  1 && z == -1) return false;
		return true;
	}
	
	// returns true for 4 out of the 27 possible tuples:
	// those on the side of the given direction,
	// and regardless of whether "corner" is in the direction 
	// those touching "corner" if it were in the direction
	public boolean inDirectionAndCorner(int direction, Tuple corner) {
		
		if (!this.facesDirection(direction)) return false;
		
		Tuple scratch = new Tuple(corner);
		if(direction == Direction.up) scratch.y = 1;
		if(direction == Direction.down) scratch.y = -1;
		if(direction == Direction.north) scratch.z = -1;
		if(direction == Direction.south) scratch.z = 1;
		if(direction == Direction.east) scratch.y = 1;
		if(direction == Direction.west) scratch.y = -1;
		
		return surroundsCorner(scratch);
	}
	
	public boolean isCenterOfFace() {
		int numberOfZeros = 0;
		if(x == 0) numberOfZeros++;
		if(y == 0) numberOfZeros++;
		if(z == 0) numberOfZeros++;
		return (numberOfZeros == 2);
	}
	
	// direction = down will return bottom face
	// results ordered for drawing with the texture facing outward
	public static ArrayList<Tuple> getFaceVertexesOfCube(int direction) {
	/*ArrayList<Tuple> bottomVertexes = new ArrayList<Tuple>() {{
		add(new Tuple(0,0,0));
	    add(new Tuple(0,0,1));
	    add(new Tuple(1,0,1));
	    add(new Tuple(1,0,0));
	}};*/
		ArrayList<Integer> x = new ArrayList<Integer>();
		ArrayList<Integer> y = new ArrayList<Integer>();
		ArrayList<Integer> z = new ArrayList<Integer>();
		switch(direction) {
			case Direction.down:
				return new ArrayList<Tuple>() {{
					add(new Tuple(0,0,0));
					add(new Tuple(1,0,0));
					add(new Tuple(1,0,1));
					add(new Tuple(0,0,1));
				}};
			case Direction.up:
				return new ArrayList<Tuple>() {{
					add(new Tuple(0,1,0));
					add(new Tuple(1,1,0));
					add(new Tuple(1,1,1));
					add(new Tuple(0,1,1));
				}};
			case Direction.north:
				return new ArrayList<Tuple>() {{
					add(new Tuple(1,0,0));
					add(new Tuple(0,0,0));
					add(new Tuple(0,1,0));
					add(new Tuple(1,1,0)); 
				}};
			case Direction.south:
				return new ArrayList<Tuple>() {{
					add(new Tuple(1,0,1));
				    add(new Tuple(1,1,1));
				    add(new Tuple(0,1,1));
				    add(new Tuple(0,0,1));
				}};
			case Direction.east:
				return new ArrayList<Tuple>() {{
					add(new Tuple(1,0,1));
				    add(new Tuple(1,1,1));
				    add(new Tuple(1,1,0));
				    add(new Tuple(1,0,0));
				}};
			case Direction.west:
			default:
				return new ArrayList<Tuple>() {{
					add(new Tuple(0,0,1));
				    add(new Tuple(0,1,1));
				    add(new Tuple(0,1,0));
				    add(new Tuple(0,0,0));
				}};		
		}
	}
	
	// given direction facing outward
	// returns U-offset for a texture
	public double getTextureU(int direction) {
		switch(direction) {
		case Direction.down:
		case Direction.up:
			return x;
		case Direction.north:
			return 1-x;
		case Direction.south:
			return x;
		case Direction.east:
			return z;
		case Direction.west:
			return 1-z;
		}
		return -1; // TODO: proper handling of bad direction
	}
	
	// given direction facing outward
	// returns U-offset for a texture
	public double getTextureV(int direction) {
		switch (direction) {
		case Direction.down:
		case Direction.up:
			return z;
		default:
			return y;
		}
	}
}

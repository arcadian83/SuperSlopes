package net.arcadian83.common;

import java.util.HashMap;
import java.util.Map;

public class Tuple implements Comparable<Tuple> {
	public Integer x;
	public Integer y;
	public Integer z;
	
	public Tuple(int x, int y, int z) {
		this.x = x;
		this.y = y;
		this.z = z;
	}
	
	public Tuple(Tuple toCopy) {
		this.x = toCopy.x;
		this.y = toCopy.y;
		this.z = toCopy.z;
	}
	
	// auto-generated by Eclipse
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((x == null) ? 0 : x.hashCode());
		result = prime * result + ((y == null) ? 0 : y.hashCode());
		result = prime * result + ((z == null) ? 0 : z.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object other) {
		if (other == null) return false;
	    if (other == this) return true;
	    if (!(other instanceof Tuple))return false;
	    Tuple otherTuple = (Tuple)other;
	    
		if(this.x != otherTuple.x) return false;
		if(this.y != otherTuple.y) return false;
		if(this.z != otherTuple.z) return false;
		return true;
	}
	
	@Override
	public int compareTo(Tuple other)
    {
		if(other == this) return 0;
    
	    int xCompare = this.x.compareTo(other.x);
	    if(xCompare != 0) return xCompare;
	    
	    int yCompare = this.y.compareTo(other.y);
	    if(yCompare != 0) return yCompare;
	    
	    return z.compareTo(other.z);
    }
	
	// given a direction, determine if this Tuple is outward in that direction
	public boolean facesDirection(int direction) {
		switch(direction) {
			case 0: return (y == -1);
			case 1: return (y ==  1);
			case 2: return (z ==  1);
			case 3: return (z == -1);
			case 4: return (x == -1);
			case 5: return (x ==  1);
		}
		
		return false;
	}
	
	// given a corner Tuple, determine if we are adjacent (including diagonals) to it
	public boolean surroundsCorner(Tuple corner) {
		if(corner.x == -1 && x ==  1) return false;
		if(corner.x ==  1 && x == -1) return false;
		if(corner.y == -1 && y ==  1) return false;
		if(corner.y ==  1 && y == -1) return false;
		if(corner.z == -1 && z ==  1) return false;
		if(corner.z ==  1 && z == -1) return false;
		return true;
	}
	
	public boolean isCenterOfFace() {
		int numberOfZeros = 0;
		if(x == 0) numberOfZeros++;
		if(y == 0) numberOfZeros++;
		if(z == 0) numberOfZeros++;
		return (numberOfZeros == 2);
	}
}
